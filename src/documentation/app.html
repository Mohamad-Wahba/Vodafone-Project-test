<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>app API documentation</title>
<meta name="description" content="Vodafone Chatbot Application â€¦" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>app</code></h1>
</header>
<section id="section-intro">
<p>Vodafone Chatbot Application</p>
<p>This application provides a chat interface for interacting with a MySQL database using natural language queries.
It utilizes the Groq LLM API for query generation and response formatting.</p>
<p>The application is built with Streamlit for the frontend and includes system monitoring functionality.</p>
<p>Authors: Mohamed Bassiony, Mohamad Wahba, Beshoy Ashraf Samir, Mohamad Sharqawi
Date: July 14, 2024</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">&#34;&#34;&#34;
Vodafone Chatbot Application

This application provides a chat interface for interacting with a MySQL database using natural language queries. 
It utilizes the Groq LLM API for query generation and response formatting.

The application is built with Streamlit for the frontend and includes system monitoring functionality.

Authors: Mohamed Bassiony, Mohamad Wahba, Beshoy Ashraf Samir, Mohamad Sharqawi
Date: July 14, 2024
&#34;&#34;&#34;

import os

import streamlit as st
from dotenv import load_dotenv
from langchain_community.utilities import SQLDatabase
from langchain_core.messages import AIMessage, HumanMessage
from langchain_core.output_parsers import StrOutputParser
from langchain_core.prompts import ChatPromptTemplate
from langchain_core.runnables import RunnablePassthrough
from langchain_groq import ChatGroq

from monitoring import get_system_metrics

# Load environment variables
load_dotenv()

# Initialize session state for chat history
if &#34;chat_history&#34; not in st.session_state:
    st.session_state.chat_history = [
        AIMessage(content=&#34;Hello ðŸ‘‹! How can I assist you?&#34;),
    ]


def init_database(
    user: str, password: str, host: str, port: str, database: str
) -&gt; SQLDatabase:
    &#34;&#34;&#34;
    Initialize and return a SQLDatabase object for the given MySQL database.

    Args:
        user (str): Database username
        password (str): Database password
        host (str): Database host address
        port (str): Database port number
        database (str): Name of the database

    Returns:
        SQLDatabase: An initialized SQLDatabase object
    &#34;&#34;&#34;
    db_uri = f&#34;mysql+mysqlconnector://{user}:{password}@{host}:{port}/{database}&#34;
    return SQLDatabase.from_uri(db_uri)


def get_sql_chain(db: SQLDatabase):
    &#34;&#34;&#34;
    Create and return a chain for generating SQL queries based on user questions.

    Args:
        db (SQLDatabase): The initialized database object

    Returns:
        Chain: A LangChain chain for SQL query generation
    &#34;&#34;&#34;
    template = &#34;&#34;&#34;
    You are a data analyst at a company. You are interacting with a user who is asking you questions about the company&#39;s database.
    Based on the table schema below, write a SQL query that would answer the user&#39;s question. Take the conversation history into account.
    
    &lt;SCHEMA&gt;{schema}&lt;/SCHEMA&gt;
    
    Conversation History: {chat_history}
    
    Write only the SQL query and nothing else. Do not wrap the SQL query in any other text, not even backticks.
    
    For example:
    Question: which 3 artists have the most tracks?
    SQL Query: SELECT ArtistId, COUNT(*) as track_count FROM Track GROUP BY ArtistId ORDER BY track_count DESC LIMIT 3;
    Question: Name 10 artists
    SQL Query: SELECT Name FROM Artist LIMIT 10;
    
    Your turn:
    
    Question: {question}
    SQL Query:
    &#34;&#34;&#34;

    prompt = ChatPromptTemplate.from_template(template)
    llm = ChatGroq(model=&#34;llama-3.1-70b-versatile&#34;, temperature=0)

    def get_schema(_):
        return db.get_table_info()

    return (
        RunnablePassthrough.assign(schema=get_schema) | prompt | llm | StrOutputParser()
    )


def get_response(user_query: str, db: SQLDatabase, chat_history: list) -&gt; str:
    &#34;&#34;&#34;
    Generate a response to the user&#39;s query using the database and chat history.

    Args:
        user_query (str): The user&#39;s input question
        db (SQLDatabase): The initialized database object
        chat_history (list): List of previous messages in the conversation

    Returns:
        str: A natural language response to the user&#39;s query
    &#34;&#34;&#34;
    sql_chain = get_sql_chain(db)

    template = &#34;&#34;&#34;
    You are a data analyst at a company. You are interacting with a user who is asking you questions about the company&#39;s database.
    Based on the table schema below, question, sql query, and sql response, write a natural language response.
    &lt;SCHEMA&gt;{schema}&lt;/SCHEMA&gt;

    Conversation History: {chat_history}
    SQL Query: &lt;SQL&gt;{query}&lt;/SQL&gt;
    User question: {question}
    SQL Response: {response}&#34;&#34;&#34;

    prompt = ChatPromptTemplate.from_template(template)
    llm = ChatGroq(model=&#34;llama-3.1-70b-versatile&#34;, temperature=0)

    chain = (
        RunnablePassthrough.assign(query=sql_chain).assign(
            schema=lambda _: db.get_table_info(),
            response=lambda vars: db.run(vars[&#34;query&#34;]),
        )
        | prompt
        | llm
        | StrOutputParser()
    )

    return chain.invoke(
        {
            &#34;question&#34;: user_query,
            &#34;chat_history&#34;: chat_history,
        }
    )


# Streamlit app
def main():
    &#34;&#34;&#34;
    Main function to run the Streamlit app.
    &#34;&#34;&#34;
    st.set_page_config(page_title=&#34;Vodafone chatbot&#34;, page_icon=&#34;:speech_balloon:&#34;)
    st.title(&#34;Chat with Vodafone database&#34;)

    # Sidebar for database connection settings and system monitoring
    with st.sidebar:
        st.image(&#34;https://1000logos.net/wp-content/uploads/2017/06/Vodafone_Logo.png&#34;)
        st.subheader(&#34;Settings&#34;)
        st.write(&#34;Connect Vodafone local database and start chatting.&#34;)

        st.text_input(&#34;Host&#34;, value=os.getenv(&#34;DB_HOST&#34;, &#34;localhost&#34;), key=&#34;Host&#34;)
        st.text_input(&#34;Port&#34;, value=os.getenv(&#34;DB_PORT&#34;, &#34;3306&#34;), key=&#34;Port&#34;)
        st.text_input(&#34;User&#34;, value=os.getenv(&#34;DB_USER&#34;, &#34;root&#34;), key=&#34;User&#34;)
        st.text_input(
            &#34;Password&#34;,
            type=&#34;password&#34;,
            value=os.getenv(&#34;DB_PASSWORD&#34;, &#34;&#34;),
            key=&#34;Password&#34;,
        )
        st.text_input(&#34;Database&#34;, value=os.getenv(&#34;DB_NAME&#34;, &#34;Chinook&#34;), key=&#34;Database&#34;)

        if st.button(&#34;Connect&#34;):
            with st.spinner(&#34;Connecting to database...&#34;):
                db = init_database(
                    st.session_state[&#34;User&#34;],
                    st.session_state[&#34;Password&#34;],
                    st.session_state[&#34;Host&#34;],
                    st.session_state[&#34;Port&#34;],
                    st.session_state[&#34;Database&#34;],
                )
                st.session_state.db = db
                st.success(&#34;Connected to database!&#34;)

        # System Monitoring Section
        st.subheader(&#34;System Monitoring&#34;)
        if st.checkbox(&#34;Show System Metrics&#34;):
            metrics = get_system_metrics()
            st.metric(&#34;CPU Usage&#34;, f&#34;{metrics[&#39;cpu_usage&#39;]}%&#34;)
            st.metric(&#34;Memory Usage&#34;, f&#34;{metrics[&#39;memory_usage&#39;]}%&#34;)
            st.metric(&#34;Disk Usage&#34;, f&#34;{metrics[&#39;disk_usage&#39;]}%&#34;)

    # Display chat history
    for message in st.session_state.chat_history:
        if isinstance(message, AIMessage):
            with st.chat_message(
                &#34;AI&#34;,
                avatar=&#34;https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTJ9uo29rKi1lXepifVFHiXtetcFLN7dyZhcQ&amp;s&#34;,
            ):
                st.markdown(message.content)
        elif isinstance(message, HumanMessage):
            with st.chat_message(&#34;Human&#34;):
                st.markdown(message.content)

    # Handle user input
    user_query = st.chat_input(&#34;Type a message...&#34;)
    if user_query is not None and user_query.strip() != &#34;&#34;:
        st.session_state.chat_history.append(HumanMessage(content=user_query))

        with st.chat_message(&#34;Human&#34;):
            st.markdown(user_query)

        with st.chat_message(
            &#34;AI&#34;,
            avatar=&#34;https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTJ9uo29rKi1lXepifVFHiXtetcFLN7dyZhcQ&amp;s&#34;,
        ):
            response = get_response(
                user_query, st.session_state.db, st.session_state.chat_history
            )
            st.markdown(response)

        st.session_state.chat_history.append(AIMessage(content=response))


if __name__ == &#34;__main__&#34;:
    main()

# FastAPI related code (commented out)
&#34;&#34;&#34;
from fastapi import FastAPI
from pydantic import BaseModel

api = FastAPI()

class Query(BaseModel):
    question: str

@api.post(&#34;/api/chat&#34;)
async def chat(query: Query):
    db = init_database(
        st.session_state[&#34;User&#34;],
        st.session_state[&#34;Password&#34;],
        st.session_state[&#34;Host&#34;],
        st.session_state[&#34;Port&#34;],
        st.session_state[&#34;Database&#34;]
    )
    response = get_response(query.question, db, st.session_state.chat_history)
    return {&#34;response&#34;: response}

# Mount Streamlit app to FastAPI
# app = WSGIMiddleware(st.server.Server.get_current()._get_server_app())
# api.mount(&#34;/&#34;, app)
&#34;&#34;&#34;</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="app.get_response"><code class="name flex">
<span>def <span class="ident">get_response</span></span>(<span>user_query:Â str, db:Â langchain_community.utilities.sql_database.SQLDatabase, chat_history:Â list) â€‘>Â str</span>
</code></dt>
<dd>
<div class="desc"><p>Generate a response to the user's query using the database and chat history.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>user_query</code></strong> :&ensp;<code>str</code></dt>
<dd>The user's input question</dd>
<dt><strong><code>db</code></strong> :&ensp;<code>SQLDatabase</code></dt>
<dd>The initialized database object</dd>
<dt><strong><code>chat_history</code></strong> :&ensp;<code>list</code></dt>
<dd>List of previous messages in the conversation</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>str</code></dt>
<dd>A natural language response to the user's query</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_response(user_query: str, db: SQLDatabase, chat_history: list) -&gt; str:
    &#34;&#34;&#34;
    Generate a response to the user&#39;s query using the database and chat history.

    Args:
        user_query (str): The user&#39;s input question
        db (SQLDatabase): The initialized database object
        chat_history (list): List of previous messages in the conversation

    Returns:
        str: A natural language response to the user&#39;s query
    &#34;&#34;&#34;
    sql_chain = get_sql_chain(db)

    template = &#34;&#34;&#34;
    You are a data analyst at a company. You are interacting with a user who is asking you questions about the company&#39;s database.
    Based on the table schema below, question, sql query, and sql response, write a natural language response.
    &lt;SCHEMA&gt;{schema}&lt;/SCHEMA&gt;

    Conversation History: {chat_history}
    SQL Query: &lt;SQL&gt;{query}&lt;/SQL&gt;
    User question: {question}
    SQL Response: {response}&#34;&#34;&#34;

    prompt = ChatPromptTemplate.from_template(template)
    llm = ChatGroq(model=&#34;llama-3.1-70b-versatile&#34;, temperature=0)

    chain = (
        RunnablePassthrough.assign(query=sql_chain).assign(
            schema=lambda _: db.get_table_info(),
            response=lambda vars: db.run(vars[&#34;query&#34;]),
        )
        | prompt
        | llm
        | StrOutputParser()
    )

    return chain.invoke(
        {
            &#34;question&#34;: user_query,
            &#34;chat_history&#34;: chat_history,
        }
    )</code></pre>
</details>
</dd>
<dt id="app.get_sql_chain"><code class="name flex">
<span>def <span class="ident">get_sql_chain</span></span>(<span>db:Â langchain_community.utilities.sql_database.SQLDatabase)</span>
</code></dt>
<dd>
<div class="desc"><p>Create and return a chain for generating SQL queries based on user questions.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>db</code></strong> :&ensp;<code>SQLDatabase</code></dt>
<dd>The initialized database object</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>Chain</code></dt>
<dd>A LangChain chain for SQL query generation</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def get_sql_chain(db: SQLDatabase):
    &#34;&#34;&#34;
    Create and return a chain for generating SQL queries based on user questions.

    Args:
        db (SQLDatabase): The initialized database object

    Returns:
        Chain: A LangChain chain for SQL query generation
    &#34;&#34;&#34;
    template = &#34;&#34;&#34;
    You are a data analyst at a company. You are interacting with a user who is asking you questions about the company&#39;s database.
    Based on the table schema below, write a SQL query that would answer the user&#39;s question. Take the conversation history into account.
    
    &lt;SCHEMA&gt;{schema}&lt;/SCHEMA&gt;
    
    Conversation History: {chat_history}
    
    Write only the SQL query and nothing else. Do not wrap the SQL query in any other text, not even backticks.
    
    For example:
    Question: which 3 artists have the most tracks?
    SQL Query: SELECT ArtistId, COUNT(*) as track_count FROM Track GROUP BY ArtistId ORDER BY track_count DESC LIMIT 3;
    Question: Name 10 artists
    SQL Query: SELECT Name FROM Artist LIMIT 10;
    
    Your turn:
    
    Question: {question}
    SQL Query:
    &#34;&#34;&#34;

    prompt = ChatPromptTemplate.from_template(template)
    llm = ChatGroq(model=&#34;llama-3.1-70b-versatile&#34;, temperature=0)

    def get_schema(_):
        return db.get_table_info()

    return (
        RunnablePassthrough.assign(schema=get_schema) | prompt | llm | StrOutputParser()
    )</code></pre>
</details>
</dd>
<dt id="app.init_database"><code class="name flex">
<span>def <span class="ident">init_database</span></span>(<span>user:Â str, password:Â str, host:Â str, port:Â str, database:Â str) â€‘>Â langchain_community.utilities.sql_database.SQLDatabase</span>
</code></dt>
<dd>
<div class="desc"><p>Initialize and return a SQLDatabase object for the given MySQL database.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>user</code></strong> :&ensp;<code>str</code></dt>
<dd>Database username</dd>
<dt><strong><code>password</code></strong> :&ensp;<code>str</code></dt>
<dd>Database password</dd>
<dt><strong><code>host</code></strong> :&ensp;<code>str</code></dt>
<dd>Database host address</dd>
<dt><strong><code>port</code></strong> :&ensp;<code>str</code></dt>
<dd>Database port number</dd>
<dt><strong><code>database</code></strong> :&ensp;<code>str</code></dt>
<dd>Name of the database</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>SQLDatabase</code></dt>
<dd>An initialized SQLDatabase object</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def init_database(
    user: str, password: str, host: str, port: str, database: str
) -&gt; SQLDatabase:
    &#34;&#34;&#34;
    Initialize and return a SQLDatabase object for the given MySQL database.

    Args:
        user (str): Database username
        password (str): Database password
        host (str): Database host address
        port (str): Database port number
        database (str): Name of the database

    Returns:
        SQLDatabase: An initialized SQLDatabase object
    &#34;&#34;&#34;
    db_uri = f&#34;mysql+mysqlconnector://{user}:{password}@{host}:{port}/{database}&#34;
    return SQLDatabase.from_uri(db_uri)</code></pre>
</details>
</dd>
<dt id="app.main"><code class="name flex">
<span>def <span class="ident">main</span></span>(<span>)</span>
</code></dt>
<dd>
<div class="desc"><p>Main function to run the Streamlit app.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def main():
    &#34;&#34;&#34;
    Main function to run the Streamlit app.
    &#34;&#34;&#34;
    st.set_page_config(page_title=&#34;Vodafone chatbot&#34;, page_icon=&#34;:speech_balloon:&#34;)
    st.title(&#34;Chat with Vodafone database&#34;)

    # Sidebar for database connection settings and system monitoring
    with st.sidebar:
        st.image(&#34;https://1000logos.net/wp-content/uploads/2017/06/Vodafone_Logo.png&#34;)
        st.subheader(&#34;Settings&#34;)
        st.write(&#34;Connect Vodafone local database and start chatting.&#34;)

        st.text_input(&#34;Host&#34;, value=os.getenv(&#34;DB_HOST&#34;, &#34;localhost&#34;), key=&#34;Host&#34;)
        st.text_input(&#34;Port&#34;, value=os.getenv(&#34;DB_PORT&#34;, &#34;3306&#34;), key=&#34;Port&#34;)
        st.text_input(&#34;User&#34;, value=os.getenv(&#34;DB_USER&#34;, &#34;root&#34;), key=&#34;User&#34;)
        st.text_input(
            &#34;Password&#34;,
            type=&#34;password&#34;,
            value=os.getenv(&#34;DB_PASSWORD&#34;, &#34;&#34;),
            key=&#34;Password&#34;,
        )
        st.text_input(&#34;Database&#34;, value=os.getenv(&#34;DB_NAME&#34;, &#34;Chinook&#34;), key=&#34;Database&#34;)

        if st.button(&#34;Connect&#34;):
            with st.spinner(&#34;Connecting to database...&#34;):
                db = init_database(
                    st.session_state[&#34;User&#34;],
                    st.session_state[&#34;Password&#34;],
                    st.session_state[&#34;Host&#34;],
                    st.session_state[&#34;Port&#34;],
                    st.session_state[&#34;Database&#34;],
                )
                st.session_state.db = db
                st.success(&#34;Connected to database!&#34;)

        # System Monitoring Section
        st.subheader(&#34;System Monitoring&#34;)
        if st.checkbox(&#34;Show System Metrics&#34;):
            metrics = get_system_metrics()
            st.metric(&#34;CPU Usage&#34;, f&#34;{metrics[&#39;cpu_usage&#39;]}%&#34;)
            st.metric(&#34;Memory Usage&#34;, f&#34;{metrics[&#39;memory_usage&#39;]}%&#34;)
            st.metric(&#34;Disk Usage&#34;, f&#34;{metrics[&#39;disk_usage&#39;]}%&#34;)

    # Display chat history
    for message in st.session_state.chat_history:
        if isinstance(message, AIMessage):
            with st.chat_message(
                &#34;AI&#34;,
                avatar=&#34;https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTJ9uo29rKi1lXepifVFHiXtetcFLN7dyZhcQ&amp;s&#34;,
            ):
                st.markdown(message.content)
        elif isinstance(message, HumanMessage):
            with st.chat_message(&#34;Human&#34;):
                st.markdown(message.content)

    # Handle user input
    user_query = st.chat_input(&#34;Type a message...&#34;)
    if user_query is not None and user_query.strip() != &#34;&#34;:
        st.session_state.chat_history.append(HumanMessage(content=user_query))

        with st.chat_message(&#34;Human&#34;):
            st.markdown(user_query)

        with st.chat_message(
            &#34;AI&#34;,
            avatar=&#34;https://encrypted-tbn0.gstatic.com/images?q=tbn:ANd9GcTJ9uo29rKi1lXepifVFHiXtetcFLN7dyZhcQ&amp;s&#34;,
        ):
            response = get_response(
                user_query, st.session_state.db, st.session_state.chat_history
            )
            st.markdown(response)

        st.session_state.chat_history.append(AIMessage(content=response))</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="app.get_response" href="#app.get_response">get_response</a></code></li>
<li><code><a title="app.get_sql_chain" href="#app.get_sql_chain">get_sql_chain</a></code></li>
<li><code><a title="app.init_database" href="#app.init_database">init_database</a></code></li>
<li><code><a title="app.main" href="#app.main">main</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>